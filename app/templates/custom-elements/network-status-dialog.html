<template id="network-status-dialog-template">
  <style>
    @import "css/style.css";

    #initializing,
    #display {
      display: none;
    }

    :host([state="initializing"]) #initializing,
    :host([state="display"]) #display {
      display: block;
    }

    :host(:not([show-status-eth0])) #status-eth0,
    :host(:not([show-status-eth1])) #status-eth1,
    :host(:not([show-status-wlan0])) #status-wlan0 {
      display: none;
    }

    .info-container {
      margin-bottom: 1em;
    }
  </style>

  <div id="initializing">
    <h3>Determining Network Status</h3>
    <div>
      <progress-spinner></progress-spinner>
    </div>
  </div>

  <div id="display">
    <h3>Network Status</h3>
    <div class="info-container">
      <network-status-interface id="status-eth0"></network-status-interface>
      <network-status-interface id="status-eth1"></network-status-interface>
      <network-status-interface id="status-wlan0"></network-status-interface>
    </div>
    <div class="button-container">
      <button id="close-button" type="button">Close</button>
    </div>
  </div>
</template>

<script type="module">
  import {
    DialogClosedEvent,
    DialogCloseStateChangedEvent,
    DialogFailedEvent,
  } from "/js/events.js";
  import { getNetworkStatus } from "/js/controllers.js";

  (function () {
    const template = document.querySelector("#network-status-dialog-template");

    customElements.define(
      "network-status-dialog",
      class extends HTMLElement {
        _states = {
          INITIALIZING: "initializing",
          DISPLAY: "display",
        };
        _statesWithoutDialogClose = new Set([this._states.INITIALIZING]);

        connectedCallback() {
          this.attachShadow({ mode: "open" }).appendChild(
            template.content.cloneNode(true)
          );
          this._elements = {
            statusEth0: this.shadowRoot.querySelector("#status-eth0"),
            statusEth1: this.shadowRoot.querySelector("#status-eth1"),
            statusWlan0: this.shadowRoot.querySelector("#status-wlan0"),
          };
          this._shouldAutoUpdate = false;
          this._updateTicker = null;

          this.addEventListener("overlay-shown", () => this._initialize());
          this.addEventListener("overlay-hidden", () => {
            // Stop the update ticker when the dialog is closed, otherwise the
            // status requests would continue to be fired even when the dialog
            // is not visible anymore.
            this._shouldAutoUpdate = false;
            clearTimeout(this._updateTicker);
          });
          this.shadowRoot
            .querySelector("#close-button")
            .addEventListener("click", () => {
              this.dispatchEvent(new DialogClosedEvent());
            });
        }

        get _state() {
          return this.getAttribute("state");
        }

        set _state(newValue) {
          this.setAttribute("state", newValue);
          this.dispatchEvent(
            new DialogCloseStateChangedEvent(
              !this._statesWithoutDialogClose.has(newValue)
            )
          );
        }

        async _initialize() {
          this._state = this._states.INITIALIZING;
          await this._update();
          this._state = this._states.DISPLAY;
          this._shouldAutoUpdate = true;
          this._startUpdateLoop();
        }

        _startUpdateLoop() {
          // The update loop is based on `setTimeout`, not `setInterval`,
          // because the latter would continue to trigger even if the
          // update function lags and happens to be slower than the interval.
          // That would result in a lot of parallel, pending requests.
          this._updateTicker = setTimeout(async () => {
            await this._update();
            if (this._shouldAutoUpdate) {
              this._startUpdateLoop();
            }
          }, 2500);
        }

        async _update() {
          // Check Ethernet/WiFi status.
          let networkStatus;
          try {
            networkStatus = await getNetworkStatus();
          } catch (error) {
            this.dispatchEvent(
              new DialogFailedEvent({
                title: "Failed to Determine Network Status",
                details: error,
              })
            );
            return;
          }
          // Transform the network status array into an object, using the
          // network interface names as keys.
          const networkStatusMap = networkStatus.reduce(
            (result, item) => ({ ...result, [item.name]: item }),
            {}
          );
          // Update each network status individually instead of recreating each
          // DOM element in a loop to avoid a flash of unstyled content.
          // https://github.com/tiny-pilot/tinypilot-pro/issues/1648
          if ("eth0" in networkStatusMap) {
            this._elements.statusEth0.setEthernetWifi(
              "LAN1",
              networkStatusMap.eth0
            );
          }
          this.toggleAttribute("show-status-eth0", "eth0" in networkStatusMap);
          if ("eth1" in networkStatusMap) {
            this._elements.statusEth1.setEthernetWifi(
              "LAN2",
              networkStatusMap.eth1
            );
          }
          this.toggleAttribute("show-status-eth1", "eth1" in networkStatusMap);
          if ("wlan0" in networkStatusMap) {
            this._elements.statusWlan0.setEthernetWifi(
              `Wi-Fi`,
              networkStatusMap.wlan0
            );
          }
          this.toggleAttribute(
            "show-status-wlan0",
            "wlan0" in networkStatusMap
          );
        }
      }
    );
  })();
</script>
