<template id="input-event-indicator-template">
  <style>
    @import "css/style.css";

    .array {
      display: flex;
    }

    .item {
      border-width: 1px;
      border-color: white;
      padding: 0.1em 0.3em;
      margin-left: 0.5em;
      border-radius: 4px;
      opacity: 0.6;
      min-width: 0.8em;
      animation: appear ease 200ms forwards;
    }

    .item:nth-last-child(n + 8) {
      display: none;
    }

    .pending {
      border-style: dotted;
      background-color: #acacacac;
    }

    .succeeded {
      border-style: solid;
      background-color: #7e7e7e7e;
    }

    .failed {
      border-style: solid;
      background-color: var(--brand-red-bright);
    }

    @keyframes appear {
      0% {
        opacity: 1;
        background-color: #888;
        border-style: solid;
      }
    }

    .hide {
      animation: disappear ease 200ms forwards;
    }
    @keyframes disappear {
      100% {
        opacity: 0;
      }
    }

    .keystroke {
      white-space: pre;
      text-align: center;
      font-family: "Overpass Mono", monospace;
      font-size: 0.9em;
    }
  </style>

  <div id="history" class="array"></div>
</template>

<script>
  (function () {
    const doc = (document._currentScript || document.currentScript)
      .ownerDocument;
    const template = doc.querySelector("#input-event-indicator-template");

    customElements.define(
      "input-event-indicator",

      /**
       * The concept of the input-event indicator is to give users feedback
       * about their input actions (e.g. keystrokes). The feedback is
       * transient, so it is only shown for a brief period of time, just long
       * enough to allow for a double-check. The overall appearance of the
       * indicator is intentionally subtle in order to not be distracting.
       *
       * The animation of newly appearing items is optimistic. Only in case an
       * item is still pending or has errored after the initial fade-in
       * duration, we mark it as such “after the fact”.
       */
      class extends HTMLElement {
        DISPLAY_THRESHOLD_MS = 4000;

        connectedCallback() {
          this.attachShadow({ mode: "open" });
          this.shadowRoot.appendChild(template.content.cloneNode(true));
          this.history = this.shadowRoot.getElementById("history");
          this.isEnabled = true;
        }

        enable() {
          this.isEnabled = true;
        }

        disable() {
          this.isEnabled = false;
          Array.from(this.history.childNodes).forEach((item) => {
            item.style.display = "none";
          });
        }

        pushKeystroke(key) {
          if (!this.isEnabled) {
            return {
              succeeded: () => {},
              failed: () => {},
            };
          }
          const item = document.createElement("div");
          item.innerText = key;
          item.classList.add("keystroke");
          return this.push(item, "Keystroke");
        }

        push(item, title) {
          item.classList.add("item", "pending");
          item.title = `${title} pending...`;
          this.history.appendChild(item);
          setTimeout(() => this.pop(item), this.DISPLAY_THRESHOLD_MS);
          return {
            succeeded: () => {
              item.classList.remove("pending");
              item.classList.add("succeeded");
              item.title = `${title} succeeded`;
            },
            failed: () => {
              item.classList.remove("pending");
              item.classList.add("failed");
              item.title = `${title} failed`;
            },
          };
        }

        pop(item) {
          item.classList.add("hide");
          // Give the animation enough time to complete, then eventually
          // garbage-collect the item.
          setTimeout(() => {
            item.style.display = "none"; // Prevent flickering on removal
            this.history.removeChild(item);
          }, 500);
        }
      }
    );
  })();
</script>
