<template id="remote-screen-template">
  <style>
    @import "css/cursors.css";

    * {
      background: rgb(114, 114, 114);
    }

    :host([fullscreen="false"]) {
      padding: 0 1rem;
    }

    :host([fullscreen="false"]) #remote-screen-img {
      max-width: 85%;
      max-height: 1080px;
    }

    :host([fullscreen="true"]) {
      display: grid;
      overflow: auto;
    }

    :host([fullscreen="true"]) #remote-screen-img {
      margin: auto;
      max-height: 100vh;
      max-width: 100vw;
    }
  </style>
  <div id="remote-screen" fullscreen="false">
    <img id="remote-screen-img" src="/stream?advance_headers=1" />
  </div>
</template>

<script>
  (function () {
    const doc = (document._currentScript || document.currentScript)
      .ownerDocument;
    const template = doc.querySelector("#remote-screen-template");

    let remoteScreen, remoteScreenImg;

    function setScreenImgSize(fullscreen = false) {
      remoteScreen.setAttribute("fullscreen", fullscreen);
      remoteScreenImg.style.removeProperty("width");
      remoteScreenImg.style.removeProperty("height");
      if (fullscreen) {
        const windowRatio = window.innerWidth / window.innerHeight;
        const screenRatio = remoteScreenImg.width / remoteScreenImg.height;
        if (screenRatio > windowRatio) {
          remoteScreenImg.style.width = "100%";
        }
        if (windowRatio >= screenRatio) {
          remoteScreenImg.style.height = "100%";
        }
      }
    }

    function sendMouseEvent(evt) {
      if (!connectedToServer) {
        return;
      }
      const boundingRect = evt.target.getBoundingClientRect();
      const cursorX = Math.max(0, evt.clientX - boundingRect.left);
      const cursorY = Math.max(0, evt.clientY - boundingRect.top);
      const width = boundingRect.right - boundingRect.left;
      const height = boundingRect.bottom - boundingRect.top;
      const relativeX = Math.min(1.0, Math.max(0.0, cursorX / width));
      const relativeY = Math.min(1.0, Math.max(0.0, cursorY / height));
      socket.emit("mouse-event", {
        buttons: evt.buttons,
        relativeX: relativeX,
        relativeY: relativeY,
      });
    }

    customElements.define(
      "remote-screen",
      class extends HTMLElement {
        constructor() {
          super();
        }

        connectedCallback() {
          console.log(template);
          this.attachShadow({ mode: "open" });
          this.shadowRoot.appendChild(template.content.cloneNode(true));

          remoteScreen = this.shadowRoot.getElementById("remote-screen");
          remoteScreenImg = this.shadowRoot.getElementById("remote-screen-img");

          remoteScreenImg.addEventListener("dragstart", function (evt) {
            // Prevent drag on screen for Firefox.
            evt.preventDefault();
          });
          remoteScreenImg.addEventListener("drop", function (evt) {
            // Prevent drop on screen for Firefox.
            evt.preventDefault();
          });
          remoteScreen.addEventListener("fullscreenchange", (evt) => {
            if (evt.target !== remoteScreen) {
              remoteScreen.setAttribute("fullscreen", false);
              this.fullscreen = "false";
            }
          });

          // Forward all mouse activity that occurs over the image of the remote screen.
          remoteScreenImg.addEventListener("mousemove", (evt) => {
            // Ensure that mouse drags don't attempt to drag the image on the screen.
            evt.preventDefault();
            sendMouseEvent(evt);
          });
          remoteScreenImg.addEventListener("mousedown", sendMouseEvent);
          remoteScreenImg.addEventListener("mouseup", sendMouseEvent);
          // Ignore the context menu so that it doesn't block the screen when the user
          // right-clicks.
          remoteScreenImg.addEventListener("contextmenu", function (evt) {
            evt.preventDefault();
          });
        }

        get fullscreen() {
          return this.getAttribute("fullscreen") === "true";
        }

        set fullscreen(newValue) {
          this.setAttribute("fullscreen", newValue);
        }

        get cursor() {
          return this.getAttribute("cursor");
        }

        set cursor(newValue) {
          this.setAttribute("cursor", newValue);
        }

        get disabled() {
          return this.getAttribute("disabled") === "true";
        }

        set disabled(newValue) {
          this.setAttribute("disabled", newValue);
        }

        static get observedAttributes() {
          return ["fullscreen", "cursor", "disabled"];
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === "fullscreen") {
            if (newValue === "true") {
              remoteScreen.requestFullscreen();
              setTimeout(() => setScreenImgSize(true), 100);
            }
          }
          if (name === "cursor") {
            if (connectedToServer) {
              remoteScreen.setAttribute("cursor", newValue);
            }
          }
          if (name === "disabled") {
            if (newValue === "true") {
              remoteScreen.setAttribute("cursor", "disabled");
            }
            if (newValue === "false") {
              restoreCursor();
            }
          }
        }
      }
    );
  })();
</script>
